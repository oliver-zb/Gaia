import timeitimport numpy as npimport matplotlib.pyplot as pltfrom matplotlib import animationstart = timeit.default_timer()"load these data, to do this, these files have to be created with load_data.py"x = np.load('data/x.npy')y = np.load('data/y.npy')z = np.load('data/z.npy')q = np.load('data/q.npy')v_x = np.load('data/v_x.npy')v_y = np.load('data/v_y.npy')v_z = np.load('data/v_z.npy')v = np.load('data/v.npy')"anaglyphic animation""with frames, one can change the number of frames that are calculated"fig = plt.figure()ax = plt.axes()title = fig.suptitle('')frames = 1000z_c = 0x_c = 10"here, one can change the number of simulated objects, it does not make sense to go beyond 2000," \"because then many points overlap and nothing can be seen"x_s = np.array(q[0][:2000])y_s = np.array(q[1][:2000])z_s = np.array(q[2][:2000])v_x = np.array(v[0][:2000])v_y = np.array(v[1][:2000])v_z = np.array(v[2][:2000])y_c = 0.5y_min = min(q[1])y_sc = y_min + y_s"additional factor on lambda increases distance between red and blue, needed for optimisation for " \"different sceen sizes and different distances between screen and observer"lambd = (y_c / (y_c - y_sc))x_sc = lambd * (x_s - x_c) + x_cz_sc = lambd * (z_s - z_c) + z_cx_sc_1 = x_sc + lambd / 2x_sc_2 = x_sc - lambd / 2z_sc_1 = z_sc + lambd / 2z_sc_2 = z_sc - lambd / 2y_new = []lambd = []for t in range(0,frames,1):    y_min = min(y_s + v_y * t * 100)    y_sc = y_min + y_s * v_y * t * 100    lambd_new = y_c / (y_c - y_sc)    y_new.append(y_sc)    lambd.append(lambd_new)line_1, = ax.plot(x_sc_1, z_sc_1,c='r',linestyle='', marker='.',markersize=5, alpha=0.8)line_2, = ax.plot(x_sc_2, z_sc_2, c='c',linestyle='', marker='.',markersize=5, alpha=0.4)def init():    line_1.set_data([], [])    line_2.set_data([], [])    return line_1, line_2,"animation function. This is called sequentially"def animate(i):    title.set_text('{:d} * 100 years'.format(i))    new_x_1 = x_sc_1[:] + v_x[:] * i * 100    new_z_1 = z_sc_1[:] + v_z[:] * i * 100    new_x_2 = x_sc_2[:] + v_x[:] * i * 100    new_z_2 = z_sc_2[:] + v_z[:] * i * 100    line_1.set_data(new_x_1, new_z_1)    line_2.set_data(new_x_2, new_z_2)    return line_1, line_2,anim = animation.FuncAnimation(fig, animate,                               frames=frames, interval=50, blit=False, init_func=init)plt.xlim(-10,40)plt.ylim(-20,20)plt.show()stop = timeit.default_timer()print("calculation time:", round(stop - start),"s")