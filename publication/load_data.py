"""This file takes the data set that can be downloaded from the Gaia mission website""The program is written such that it reads the files drom Gaia DR2 with radial velocities" \"It is very time consuming (approximately 20 minutes), there are for sure better ways to load the data"import csvimport osimport timeitimport numpy as npstart = timeit.default_timer()"here, the columns that are needed are selected. One can add or remove that are nessecary or not, depending" \"on what data one needs. The numbers i in rows[i] correspond to the column, as described in the Gaia DR2" \"user manual." \"First, one has to download the data containing information of radial velocities from the Gaia website," \"http://cdn.gea.esac.esa.int/Gaia/gdr2/gaia_source_with_rv/csv/ and save them in a folder named data." \"The program can then be executed."def preview_csv(filename, limit):    if not os.path.isfile(filename):        print('ERROR: "{0}" file not found'.format(filename))        exit()    d = open(filename)    with open(filename, 'r', encoding='utf-8') as csv_file:        reader = csv.reader(d, delimiter=limit)  # for some datasets use ; for other use ,        ncol = len(next(reader))        print("number of columns:", ncol)  # counts number of columns        dict = {rows[1]:[rows[5],rows[6],rows[7],rows[8],rows[9],rows[10],rows[11],rows[12],rows[13],rows[14],            rows[15],rows[16],rows[17],rows[18],rows[19],rows[20],rows[21],rows[22],rows[23],rows[24],            rows[25],rows[66],rows[67],rows[73],rows[74],rows[75],rows[76],rows[78],rows[79],rows[80]] for rows in reader}        "values in dict: [0]: ra, [1]: ra_err, [2]: dec, [3]: dec_err, [4]: parallax, [5]: parallax_err," \        "[6]: parallax_over_err, [7]: pmra (mu_alpha*), [8]: pmra_err, [9]: pmdec (mu_delta), [10]: pmdec_err," \        "[11]: ra_dec_corr, [12]: ra_parallax_corr, [13]: ra_pmra_corr, [14]: ra_pmdec_corr," \        "[15]: dec_parallax_corr, [16]: dec_pmra_corr, [17]: dec_pmdec_corr, [18]: parallax_pmra_corr," \        "[19]: parallax_pmdec_corr, [20]: pmra_pmdec_corr, [21]: radial_velocity, [22]: radial_velocity_err," \        "[23]: l (galactig longitude), [24]: b (galactig latitude), [25]: ecliptic_longitude," \        "[26]: ecliptic_latitude, [27]: temperature, [28]: teff_percentile_lower, [29]: temp_percentile_upper"    delete = []    for key in dict:        if any(s == '' for s in dict[key][1:]):            delete.append(key)            "contains empty string, continue now"            continue    for i in delete:        dict.pop(i, None)#    print('len(dict) without empty cells', len(dict))    return dictdata = preview_csv("data/GaiaSource_6714230465835878784_6917528443525529728.csv", ',') # approx 8 secondsdata.update(preview_csv("data/GaiaSource_2851858288640_1584379458008952960.csv", ','))data.update(preview_csv("data/GaiaSource_1584380076484244352_2200921635402776448.csv", ','))data.update(preview_csv("data/GaiaSource_2200921875920933120_3650804325670415744.csv", ','))data.update(preview_csv("data/GaiaSource_3650805523966057472_4475721411269270528.csv", ','))data.update(preview_csv("data/GaiaSource_4475722064104327936_5502601461277677696.csv", ','))data.update(preview_csv("data/GaiaSource_5502601873595430784_5933051501826387072.csv", ','))data.update(preview_csv("data/GaiaSource_5933051914143228928_6714230117939284352.csv", ','))"here, one can make suitable selection criteria, depending one what one wants to examine"print('len(data) before: ',len(data))delete = []for key in data:    if eval(data[key][4]) <= 0.001:        delete.append(key)        "to delete stars with too small parallax (data too bad)"    elif eval(data[key][5])/eval(data[key][4]) > 0.1:        delete.append(key)        "delete parallaxes with error more than 10% because positionns far away with big error" \        "have bad influence on result"    elif eval(data[key][8]) / np.absolute(eval(data[key][7])) > 0.1:        delete.append(key)        "delete pmra with error more than 10% "    elif eval(data[key][10]) / np.absolute(eval(data[key][9])) > 0.1:        delete.append(key)        "delete pmdec with error more than 10% "    elif eval((data[key][27])) > 7000:        delete.append(key)    #    "deletes stars hotter than 7000 K which are supposed to be young and have their origin in the milkyway"    elif 5*(eval(data[key][29])-eval(data[key][28])) > eval(data[key][27]):        delete.append(key)        "deletes temperatures with too big uncertainties"    elif np.absolute(eval(data[key][22])) > 5:        delete.append(key)        "deletes high radial velocitiy-error stars"    # elif eval(data[key][22]) / np.absolute(eval(data[key][21])) > 0.1:    #     delete.append(key)    #     "delete rv with error more than 10% "    # elif 1000 / eval(data[key][4]) > 100:    #     delete.append(key)    #     "that we have stars closer than 100 pc"for i in delete:    data.pop(i, None)print('len(data) after: ',len(data))int = timeit.default_timer()print("calculation time int:", round(int - start),"s")key = list(data.keys())name=[]ra = []dec = []parallax = []pmra = []pmdec = []rv = []rv_err = []par_err = []pmra_err = []pmdec_err = []ra_err = []dec_err = []temp = []temp_low_err = []temp_upp_err = []l = []b = []for key in data:    name.append(key)    ra.append(eval(data[key][0]))    ra_err.append(eval(data[key][1]))    dec.append(eval(data[key][2]))    dec_err.append(eval(data[key][3]))    parallax.append(eval(data[key][4]))    pmra.append(eval(data[key][7]))    pmdec.append(eval(data[key][9]))    rv.append(eval(data[key][21]))    rv_err.append(eval(data[key][22]))    par_err.append(eval(data[key][5]))    pmra_err.append(eval(data[key][8]))    pmdec_err.append(eval(data[key][10]))    temp.append(eval(data[key][27]))    temp_low_err.append(eval(data[key][28]))    temp_upp_err.append(eval(data[key][29]))    l.append(eval(data[key][23]))    b.append(eval(data[key][24]))rv=np.array(rv)rv_err=np.array(rv_err)print(ra[0], dec[0], parallax[0], pmra[0], pmdec[0], rv[0], temp[0])par_err=np.array([i for i in par_err])"computes cartesian positions from equatorial coordinates"ra = [i*np.pi/180 for i in ra]dec = [i*np.pi/180 for i in dec]dist = [1000/i for i in parallax]k = 149597870.7/(86400*365.25) * 1e-3   # au/yr to km/spmra = np.array([k*i for i in pmra])pmra_err = np.array([k*i for i in pmra_err])pmdec = np.array([k*i for i in pmdec])pmdec_err = np.array([k*i for i in pmdec_err])csra, snra = np.cos(ra), np.sin(ra)csdec, sndec = np.cos(dec), np.sin(dec)x = dist*csdec*csray = dist*csdec*snraz = dist*sndec"computes cartesian velocities from equatorial coordinates"v_x = np.cos(dec) * np.cos(ra) * rv - dist * np.sin(dec) * np.cos(ra) * pmdec - dist * np.sin(ra) * pmrav_xerr_up = np.cos(dec) * np.cos(ra) * (rv + rv_err) - dist * np.sin(dec) * np.cos(ra) * (pmdec + pmdec_err)\            - dist * np.sin(ra) * (pmra + pmra_err)v_xerr_low = np.cos(dec) * np.cos(ra) * (rv - rv_err) - dist * np.sin(dec) * np.cos(ra) * (pmdec - pmdec_err)\            - dist * np.sin(ra) * (pmra - pmra_err)v_y = np.cos(dec) * np.sin(ra) * rv - dist * np.sin(dec) * np.sin(ra) * pmdec + dist * np.cos(ra) * pmrav_yerr_up = np.cos(dec) * np.sin(ra) * (rv + rv_err) - dist * np.sin(dec) * np.sin(ra) * (pmdec + pmdec_err)\            + dist * np.cos(ra) * (pmra + pmra_err)v_yerr_low = np.cos(dec) * np.sin(ra) * (rv - rv_err) - dist * np.sin(dec) * np.sin(ra) * (pmdec - pmdec_err)\            + dist * np.cos(ra) * (pmra - pmra_err)v_z = np.sin(dec) * rv + dist * np.cos(dec) * pmdecv_zerr_up = np.sin(dec) * (rv + rv_err) + dist * np.cos(dec) * (pmdec + pmdec_err)v_zerr_low = np.sin(dec) * (rv - rv_err) + dist * np.cos(dec) * (pmdec - pmdec_err)v_x,v_xerr_up,v_xerr_low=np.array(v_x),np.array(v_xerr_up),np.array(v_xerr_low)v_y,v_yerr_up,v_yerr_low=np.array(v_y),np.array(v_yerr_up),np.array(v_yerr_low)v_z,v_zerr_up,v_zerr_low=np.array(v_z),np.array(v_zerr_up),np.array(v_zerr_low)"saves cartesian coordinates, calculated from equatorial coordinates"np.save('data/x',x)np.save('data/y',y)np.save('data/z',z)np.save('data/v_x',v_x)np.save('data/v_y',v_y)np.save('data/v_z',v_z)np.save('data/v_x_err_up',v_xerr_up)np.save('data/v_y_err_up',v_yerr_up)np.save('data/v_z_err_up',v_zerr_up)np.save('data/v_x_err_low',v_xerr_low)np.save('data/v_y_err_low',v_yerr_low)np.save('data/v_z_err_low',v_zerr_low)"saves coordinate frame independent raw data"np.save('data/par_err', par_err)np.save('data/parallax', parallax)np.save('data/pmra', pmra)np.save('data/pmra_err',pmra_err)np.save('data/pmdec', pmdec)np.save('data/pmdec_err', pmdec_err)np.save('data/ra', ra)np.save('data/dec', dec)np.save('data/rv', rv)np.save('data/rv_err', rv_err)np.save('data/ra_err',ra_err)np.save('data/dec_err', dec_err)np.save('data/temp', temp)np.save('data/temp_upp_err', temp_upp_err)np.save('data/temp_low_err', temp_low_err)np.save('data/l', l)np.save('data/b',b)np.save('data/name', name) # this is the individual identification for each object, unique through the entire GAIA MISSION"The galactic coordinates can be found in the Gaia data-set, buth without uncertainties." \"Because of this, we transform the equatorial coordinates to galactic coordinates as follows"T = np.array([[-0.0548755604162154, -0.8734370902348850, -0.4838350155487132],                 [0.4941094278755837,-0.4448296299600112,0.7469822444972189],                 [-0.8676661490190047,-0.1980763734312015,0.4559837761750669]])X = T[0,0] * x + T[0,1] * y + T[0,2] * zY = T[1,0] * x + T[1,1] * y + T[1,2] * zZ = T[2,0] * x + T[2,1] * y + T[2,2] * zU = T[0,0] * v_x + T[0,1] * v_y + T[0,2] * v_zV = T[1,0] * v_x + T[1,1] * v_y + T[1,2] * v_zW = T[2,0] * v_x + T[2,1] * v_y + T[2,2] * v_zU_err_up = T[0,0] * (v_x + v_xerr_up) + T[0,1] * (v_y + v_yerr_up) + T[0,2] * (v_z + v_zerr_up)V_err_up = T[1,0] * (v_x + v_xerr_up) + T[1,1] * (v_y + v_yerr_up) + T[1,2] * (v_z + v_zerr_up)W_err_up = T[2,0] * (v_x + v_xerr_up) + T[2,1] * (v_y + v_yerr_up) + T[2,2] * (v_z + v_zerr_up)U_err_low = T[0,0] * (v_x - v_xerr_low) + T[0,1] * (v_y - v_yerr_low) + T[0,2] * (v_z - v_zerr_low)V_err_low = T[1,0] * (v_x - v_xerr_low) + T[1,1] * (v_y - v_yerr_low) + T[1,2] * (v_z - v_zerr_low)W_err_low = T[2,0] * (v_x - v_xerr_low) + T[2,1] * (v_y - v_yerr_low) + T[2,2] * (v_z - v_zerr_low)"Stores positions and velocities in cartesian coordinates from galactic coordinates." \"For conventions/orientations see thesis"np.save('data/x_gal',X)np.save('data/y_gal',Y)np.save('data/z_gal',Z)np.save('data/U_gal',U)np.save('data/V_gal',V)np.save('data/W_gal',W)np.save('data/U_err_up_gal',U_err_up)np.save('data/V_err_up_gal',V_err_up)np.save('data/W_err_up_gal',W_err_up)np.save('data/U_err_low_gal',U_err_low)np.save('data/V_err_low_gal',V_err_low)np.save('data/W_err_low_gal',W_err_low)stop = timeit.default_timer()print("calculation time:", round(stop - start),"s")